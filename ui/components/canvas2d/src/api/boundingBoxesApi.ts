import type { Mask, SelectionTool } from "@pixano/core";

import Konva from "konva";

import { MASK_STROKEWIDTH } from "../lib/constants";

export function addMask(
  mask: Mask,
  color: string,
  maskGroup: Konva.Group,
  image: Konva.Image,
  viewId: string,
  stage: Konva.Stage,
  zoomFactor: Record<string, number>,
) {
  const x = image.x();
  const y = image.y();
  const scale = image.scale();

  const style = new Option().style;
  style.color = color;

  //utility functions to extract coords from SVG
  //works only with SVG format "Mx0 y0 Lx1 y1 ... xn yn"
  // --> format generated by convertSegmentsToSVG
  function m_part(svg: string) {
    const splits = svg.split(" ");
    const x = splits[0].slice(1); //remove "M"
    return { x: parseInt(x), y: parseInt(splits[1]) };
  }
  function l_part(svg: string) {
    const splits = svg.split(" ");
    const x0 = splits[2].slice(1); //remove "L"
    const res = [{ x: parseInt(x0), y: parseInt(splits[3]) }];
    for (let i = 4; i < splits.length; i += 2) {
      res.push({
        x: parseInt(splits[i]),
        y: parseInt(splits[i + 1]),
      });
    }
    return res;
  }
  const maskKonva = new Konva.Shape({
    id: mask.id,
    x: x,
    y: y,
    width: stage.width(),
    height: stage.height(),
    fill: `rgba(${style.color.replace("rgb(", "").replace(")", "")}, 0.35)`,
    stroke: style.color,
    strokeWidth: MASK_STROKEWIDTH / zoomFactor[viewId],
    scale,
    visible: mask.visible,
    opacity: mask.opacity,
    listening: false,
    sceneFunc: (ctx, shape) => {
      ctx.beginPath();
      for (let i = 0; i < mask.svg.length; ++i) {
        const start = m_part(mask.svg[i]);
        ctx.moveTo(start.x, start.y);
        const l_pts = l_part(mask.svg[i]);
        for (const pt of l_pts) {
          ctx.lineTo(pt.x, pt.y);
        }
      }
      ctx.fillStrokeShape(shape);
    },
  });

  maskGroup.add(maskKonva);
}

export function destroyDeletedObjects(objectsIds: Array<string>, objectsGroup: Konva.Group) {
  // Check if Object ID still exist in list. If not, object is deleted and must be removed from group
  const objectsToDestroy: Konva.Group[] = []; // need to build a list to not destroy while looping children
  for (const obj of objectsGroup.children) {
    if (!objectsIds.includes(obj.id())) objectsToDestroy.push(obj as Konva.Group);
  }
  for (const obj of objectsToDestroy) obj.destroy();
}

export function findOrCreateCurrentMask(viewId: string, stage: Konva.Stage): Konva.Group {
  const viewLayer: Konva.Layer = stage.findOne(`#${viewId}`);

  const currentAnnGroup: Konva.Group = viewLayer.findOne("#currentAnnotation");

  // Get and update the current annotation masks
  let currentMaskGroup: Konva.Group = currentAnnGroup.findOne("#currentMask");

  if (!currentMaskGroup) {
    currentMaskGroup = new Konva.Group({
      id: "currentMask",
    });
    currentAnnGroup.add(currentMaskGroup);
  }
  return currentMaskGroup;
}

export function clearCurrentAnn(viewId: string, stage: Konva.Stage, selectedTool: SelectionTool) {
  const viewLayer: Konva.Layer = stage?.findOne(`#${viewId}`);
  if (viewLayer) {
    const currentAnnGroup: Konva.Group = viewLayer.findOne("#currentAnnotation");
    const currentMaskGroup: Konva.Group = currentAnnGroup.findOne("#currentMask");
    if (currentMaskGroup) currentMaskGroup.destroy();
    if (selectedTool?.postProcessor) selectedTool.postProcessor.reset();
  }
}
