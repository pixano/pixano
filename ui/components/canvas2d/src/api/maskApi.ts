import Konva from "konva";
import simplify from "simplify-js";

import type { MaskSVG } from "@pixano/core";
import type { PolygonGroupPoint } from "../lib/types/canvas2dTypes";

export const parseSvgPath = (svgPath: string): PolygonGroupPoint[] => {
  const regex = /([ML]?)\s*([\d.]+)\s+([\d.]+)/g;
  let match: RegExpExecArray | null;
  let result: { x: number; y: number }[] = [];
  while ((match = regex.exec(svgPath)) !== null) {
    const [, , x, y] = match;
    result.push({ x: parseFloat(x), y: parseFloat(y) });
  }
  result = simplify(result, 4, true);
  return result.map((r, i) => ({ ...r, id: i }));
};

export const convertPointToSvg = (points: PolygonGroupPoint[]) =>
  points.reduce((acc, val, i) => {
    if (i === 0) {
      return `M${val.x} ${val.y}`;
    }
    if (i === 1) {
      return `${acc} L${val.x} ${val.y}`;
    }
    return `${acc} ${val.x} ${val.y}`;
  }, "");

export const hexToRGBA = (hex: string, alpha: number) => {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return `rgba(${r},${g},${b},${alpha})`;
};

//utility functions to extract coords from SVG
//works only with SVG format "Mx0 y0 Lx1 y1 ... xn yn"
// --> format generated by convertSegmentsToSVG
function m_part(svg: string) {
  const splits = svg.split(" ");
  const x = splits[0].slice(1); //remove "M"
  return { x: parseInt(x), y: parseInt(splits[1]) };
}
function l_part(svg: string) {
  const splits = svg.split(" ");
  const x0 = splits[2]?.slice(1); //remove "L"
  const res = [{ x: parseInt(x0), y: parseInt(splits[3]) }];
  for (let i = 4; i < splits.length; i += 2) {
    res.push({
      x: parseInt(splits[i]),
      y: parseInt(splits[i + 1]),
    });
  }
  return res;
}

export const sceneFunc = (ctx: Konva.Context, shape: Konva.Shape, svg: string[]) => {
  ctx.beginPath();
  for (let i = 0; i < svg.length; ++i) {
    const start = m_part(svg[i]);
    ctx.moveTo(start.x, start.y);
    const l_pts = l_part(svg[i]);
    for (const pt of l_pts) {
      ctx.lineTo(pt.x, pt.y);
    }
  }
  ctx.fillStrokeShape(shape);
};

// Function to parse SVG path (as provided in the previous response)
function svgPathToBitmap(svgPath, width: number, height: number): number[] {
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const context = canvas.getContext("2d");

  // Draw the SVG path on the canvas
  context.clearRect(0, 0, width, height);
  context.fillStyle = "black";
  context.fill(new Path2D(svgPath));

  // Get the image data from the canvas
  const imageData = context.getImageData(0, 0, width, height).data;
  // Convert the image data to a binary bitmap
  const bitmap: number[] = [];
  for (let i = 0; i < imageData.length; i += 4) {
    // Convert RGBA to binary (considering only the alpha channel)
    bitmap.push(imageData[i + 3] === 0 ? 0 : 1);
  }
  return bitmap;
}

function rleEncode(bitmap): number[] {
  const counts: number[] = [];
  let count = 1;
  for (let i = 1; i < bitmap.length; i++) {
    if (bitmap[i] === bitmap[i - 1]) {
      count++;
    } else {
      counts.push(count);
      count = 1;
    }
  }
  // Handle the last sequence
  counts.push(count);
  return counts;
}

function reshapeArray(array: number[], rows: number, cols: number): number[] {
  if (array.length !== rows * cols) {
    throw new Error("Can't reshape with length != cols*rows");
  }
  const reshapedArray: number[] = [];
  for (let col = 0; col < cols; col++) {
    for (let row = 0; row < rows; row++) {
      reshapedArray.push(array[row * cols + col]);
    }
  }
  return reshapedArray;
}

export function runLengthEncode(svg: MaskSVG, imageWidth: number, imageHeight: number): number[] {
  let bitmap = svgPathToBitmap(svg, imageWidth, imageHeight);
  bitmap = reshapeArray(bitmap, imageHeight, imageWidth);
  return rleEncode(bitmap);
}
