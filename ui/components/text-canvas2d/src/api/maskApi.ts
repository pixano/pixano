/*-------------------------------------
Copyright: CEA-LIST/DIASI/SIALV/LVA
Author : pixano@cea.fr
License: CECILL-C
-------------------------------------*/

import Konva from "konva";
import simplify from "simplify-js";

import type { MaskSVG } from "@pixano/core";
import type { PolygonGroupPoint } from "../lib/types/textCanvas2dTypes";

export const parseSvgPath = (svgPath: string): PolygonGroupPoint[] => {
  const regex = /([ML]?)\s*([\d.]+)\s+([\d.]+)/g;
  let match: RegExpExecArray | null;
  let result: { x: number; y: number }[] = [];
  while ((match = regex.exec(svgPath)) !== null) {
    const [, , x, y] = match;
    result.push({ x: parseFloat(x), y: parseFloat(y) });
  }
  result = simplify(result, 0, true);
  return result.map((r, i) => ({ ...r, id: i }));
};

export const convertPointToSvg = (points: PolygonGroupPoint[]) =>
  points.reduce((acc, val, i) => {
    if (i === 0) {
      return `M${val.x} ${val.y}`;
    }
    if (i === 1) {
      return `${acc} L${val.x} ${val.y}`;
    }
    return `${acc} ${val.x} ${val.y}`;
  }, "");

export const hexToRGBA = (hex: string, alpha: number) => {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return `rgba(${r},${g},${b},${alpha})`;
};

//utility functions to extract coords from SVG
//works only with SVG format "Mx0 y0 Lx1 y1 ... xn yn"
// --> format generated by convertSegmentsToSVG
function m_part(svg: string) {
  const splits = svg.split(" ");
  const x = splits[0].slice(1); //remove "M"
  return { x: parseInt(x), y: parseInt(splits[1]) };
}
function l_part(svg: string) {
  const splits = svg.split(" ");
  const x0 = splits[2]?.slice(1); //remove "L"
  const res = [{ x: parseInt(x0), y: parseInt(splits[3]) }];
  for (let i = 4; i < splits.length; i += 2) {
    res.push({
      x: parseInt(splits[i]),
      y: parseInt(splits[i + 1]),
    });
  }
  return res;
}

export const sceneFunc = (ctx: Konva.Context, shape: Konva.Shape, svg: string[]) => {
  ctx.beginPath();
  for (let i = 0; i < svg.length; ++i) {
    const start = m_part(svg[i]);
    ctx.moveTo(start.x, start.y);
    const l_pts = l_part(svg[i]);
    for (const pt of l_pts) {
      ctx.lineTo(pt.x, pt.y);
    }
  }
  ctx.fillStrokeShape(shape);
};

// Fonction de conversion RLE vers chaîne de caractères
export function rleToString(cnts: number[]): string {
  let result = "";
  for (let i = 0; i < cnts.length; i++) {
    let x = cnts[i];
    // Si c'est au-delà du deuxième élément, on applique la différence avec cnts[i-2]
    if (i > 2) {
      x -= cnts[i - 2];
    }
    let more = true;
    // Encodage en utilisant 6 bits par caractère
    while (more) {
      let c = x & 0x1f; // Extraire les 5 bits de poids faible
      x >>= 5; // Décaler les bits de 5 positions vers la droite

      // Déterminer s'il y a plus de chiffres à traiter
      more = c & 0x10 ? x !== -1 : x !== 0;
      if (more) {
        c |= 0x20; // Ajouter un indicateur de continuation
      }
      // Convertir en caractère ASCII (48-111)
      result += String.fromCharCode(c + 48);
    }
  }
  return result;
}

//translation of pycocotools rleFrString from python to Typescript
export function rleFrString(s: string): number[] {
  let p = 0; // Pointer to traverse string
  const cnts: number[] = [];

  // Step 1: Decode the string s
  while (p < s.length) {
    let x = 0;
    let k = 0;
    let more = true;

    while (more) {
      const c = s.charCodeAt(p) - 48; // Decode character to integer
      x |= (c & 0x1f) << (5 * k); // Take the first 5 bits of c
      more = (c & 0x20) !== 0; // Check if there is more to decode
      p++;
      k++;
      if (!more && c & 0x10) {
        x |= -1 << (5 * k); // If negative, handle sign extension
      }
    }
    // Step 2: Handle cumulative addition
    if (cnts.length > 2) {
      x += cnts[cnts.length - 2]; // Apply shift for previous counts
    }
    cnts.push(x); // Add decoded value to cnts array
  }
  return cnts;
}

// Function to parse SVG path (as provided in the previous response)
function svgPathToBitmap(svgPath, width: number, height: number): number[] {
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const context = canvas.getContext("2d");

  // Draw the SVG path on the canvas
  context.clearRect(0, 0, width, height);
  context.fillStyle = "black";
  context.fill(new Path2D(svgPath));

  // Get the image data from the canvas
  const imageData = context.getImageData(0, 0, width, height).data;
  // Convert the image data to a binary bitmap
  const bitmap: number[] = [];
  for (let i = 0; i < imageData.length; i += 4) {
    // Convert RGBA to binary (considering only the alpha channel)
    bitmap.push(imageData[i + 3] === 0 ? 0 : 1);
  }
  return bitmap;
}

function rleEncode(bitmap): number[] {
  const counts: number[] = [];
  let count = 1;
  for (let i = 1; i < bitmap.length; i++) {
    if (bitmap[i] === bitmap[i - 1]) {
      count++;
    } else {
      counts.push(count);
      count = 1;
    }
  }
  // Handle the last sequence
  counts.push(count);
  return counts;
}

function reshapeArray(array: number[], rows: number, cols: number): number[] {
  if (array.length !== rows * cols) {
    throw new Error("Can't reshape with length != cols*rows");
  }
  const reshapedArray: number[] = [];
  for (let col = 0; col < cols; col++) {
    for (let row = 0; row < rows; row++) {
      reshapedArray.push(array[row * cols + col]);
    }
  }
  return reshapedArray;
}

export function runLengthEncode(svg: MaskSVG, imageWidth: number, imageHeight: number): number[] {
  let bitmap = svgPathToBitmap(svg, imageWidth, imageHeight);
  bitmap = reshapeArray(bitmap, imageHeight, imageWidth);
  return rleEncode(bitmap);
}
